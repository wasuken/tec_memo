---
title: "memory管理"
date: 2022-01-03
draft: false
---

# memory 管理

通常の？GC(ここでは Java あたり)と Rust の memory 管理の違いについて軽く調査した。

## Garbage collection(Java)

[https://atmarkit.itmedia.co.jp/ait/articles/0404/02/news079.html]("ガベージコレクタの仕組みを理解する")

> 現在の JVM は世代別 GC と呼ばれる GC を実装しています。一般に、生成されたオブジェクトの多くは短期間だけ必要である法則があります。そこで、オブジェクトの存在期間（世代）に注目し、寿命が短いオブジェクト（短命オブジェクト）と寿命が長いオブジェクト（長命オブジェクト）について、それぞれに対してその特性を生かし、全体的に効率よく処理を行うものが世代別 GC です。

全然わからん。

Eden?To?From?

new 時に Eden はいるっぽい？

[5 分で分かるガベージコレクションの仕組み](https://geechs-job.com/tips/details/35)

> 「あるプログラムが使用できるメモリ領域」のことを「ヒープ領域」と言います。そして、このヒープ領域はさらに「New 領域」と「Old 領域」に分けられるのです。

> New 領域には生成されたあとすぐに廃棄されるオブジェクトが入り、Old 領域にはさらに長い寿命を持つオブジェクトが入ります。Scavenge GC はそのうち New 領域のみを対象としたもので、比較的短時間で終了します。

> 一方の Full GC は、Old 領域をふくむ全領域を対象にしたものとなります。

> （状況によっては、一部領域が除外されます）Scavenge GC ほど高頻度では発生しないかわりに、終了するまでに時間がかかります。

> これも掃除のおばちゃんを例にする場合、「部屋全体の大掃除をする」といったイメージとなります。

### 総括？

- GC は何度か？GC が走るいべんとみたいなのがある？

- ２種類ある。

  - Scavenge GC: New 側が対象。

  - Full GC: すべてが対象。寿命のながい Object が増えると発生する？処理的にかなり重くなるのでさけたい。また、起動 Option で New 領域をおおめに設定することである程度抑制できるらしい。

## Rust

以下の引用はすべて下記 Page から。

[Rust のメモリ管理機能とその特徴](https://garasubo.github.io/hexo/2021/11/07/rust-memory.html)

> その一方で、GC を実行する際にプログラムを一時的に止める必要があったり、GC を走らせるまでは必要のないメモリを確保し続けたままになってしまうなど、実行時の効率が問題になるケースがあります。

GC のために CPU や Memory 使うことを全く考えていなかった。

> Rust のにおける値は唯一の所有者（owner）が存在します。変数に値を代入すると、その変数が値の所有者になります。

> 同じ値に対して複数の所有者が存在することはできません。

> 所有者である変数のスコープが終了すると、その値は解放されます。

> メモリ解放について

> 関数内のローカル変数の場合、その関数が終わるときにスタックが破棄され値も解放されますが、Box のようにヒープを使う場合どのように解放されるのでしょうか。

> 実は Box には Drop というトレイト（C++のインターフェースのようなもの）が実装されていて、その値がスコープから出たときにメモリが解放されるような実装がされています。

> 所有権システムによりその値に紐付いている変数は複数存在することはできないので、Drop トレイトによって実装されたメモリ解放の動作が同じ Box のインスタンスに対して働くことはありません。

> また、自分たちでわざわざどこでメモリを解放するかを明示する必要もありません。

- 関数がおわると内部変数はおわる。

- Box のような構造を利用すると権限がそのまま移譲される。
