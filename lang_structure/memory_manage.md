# memory管理

通常の？GC(ここではJavaあたり)とRustのmemory管理の違いについて軽く調査した。

## Garbage collection(Java)

[https://atmarkit.itmedia.co.jp/ait/articles/0404/02/news079.html]("ガベージコレクタの仕組みを理解する")

> 現在のJVMは世代別GCと呼ばれるGCを実装しています。一般に、生成されたオブジェクトの多くは短期間だけ必要である法則があります。そこで、オブジェクトの存在期間（世代）に注目し、寿命が短いオブジェクト（短命オブジェクト）と寿命が長いオブジェクト（長命オブジェクト）について、それぞれに対してその特性を生かし、全体的に効率よく処理を行うものが世代別GCです。

全然わからん。

Eden?To?From?

new時にEdenはいるっぽい？

[5分で分かるガベージコレクションの仕組み](https://geechs-job.com/tips/details/35)

> 「あるプログラムが使用できるメモリ領域」のことを「ヒープ領域」と言います。そして、このヒープ領域はさらに「New領域」と「Old領域」に分けられるのです。
> New領域には生成されたあとすぐに廃棄されるオブジェクトが入り、Old領域にはさらに長い寿命を持つオブジェクトが入ります。Scavenge GCはそのうちNew領域のみを対象としたもので、比較的短時間で終了します。

> 一方のFull GCは、Old領域をふくむ全領域を対象にしたものとなります。
> （状況によっては、一部領域が除外されます）Scavenge GCほど高頻度では発生しないかわりに、終了するまでに時間がかかります。
> これも掃除のおばちゃんを例にする場合、「部屋全体の大掃除をする」といったイメージとなります。

### 総括？

* GCは何度か？GCが走るいべんとみたいなのがある？

* ２種類ある。
  * Scavenge GC: New側が対象。
  * Full GC: すべてが対象。寿命のながいObjectが増えると発生する？処理的にかなり重くなるのでさけたい。また、起動OptionでNew領域をおおめに設定することである程度抑制できるらしい。

## Rust

以下の引用はすべて下記Pageから。

[Rustのメモリ管理機能とその特徴](https://garasubo.github.io/hexo/2021/11/07/rust-memory.html)

> その一方で、GCを実行する際にプログラムを一時的に止める必要があったり、GCを走らせるまでは必要のないメモリを確保し続けたままになってしまうなど、実行時の効率が問題になるケースがあります。

GCのためにCPUやMemory使うことを全く考えていなかった。

> Rustのにおける値は唯一の所有者（owner）が存在します。変数に値を代入すると、その変数が値の所有者になります。
> 同じ値に対して複数の所有者が存在することはできません。
> 所有者である変数のスコープが終了すると、その値は解放されます。

> メモリ解放について
> 関数内のローカル変数の場合、その関数が終わるときにスタックが破棄され値も解放されますが、Boxのようにヒープを使う場合どのように解放されるのでしょうか。
> 実はBoxにはDropというトレイト（C++のインターフェースのようなもの）が実装されていて、その値がスコープから出たときにメモリが解放されるような実装がされています。
> 所有権システムによりその値に紐付いている変数は複数存在することはできないので、Dropトレイトによって実装されたメモリ解放の動作が同じBoxのインスタンスに対して働くことはありません。
> また、自分たちでわざわざどこでメモリを解放するかを明示する必要もありません。

* 関数がおわると内部変数はおわる。

* Boxのような構造を利用すると権限がそのまま移譲される。
